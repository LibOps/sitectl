/*
Copyright Â© 2023 Joe Corall <joe@libops.io>
*/
package cmd

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"strings"

	compute "google.golang.org/api/compute/v1"

	"github.com/libops/homebrew-cli/internal/helpers"
	"github.com/libops/homebrew-cli/pkg/gcloud"
	"github.com/libops/homebrew-cli/pkg/libops"
	"github.com/spf13/cobra"
)

// addconfigSshCmd represents the addconfigSsh command
var configSshCmd = &cobra.Command{
	Use:   "config-ssh",
	Short: "Populate ~/.ssh/config with LibOps development environment",
	Long: `Populate ~/.ssh/config with LibOps development environment
    This will make SFTP'ing to your development environment easier.`,
	Run: func(cmd *cobra.Command, args []string) {
		var err error
		site, env, err := libops.LoadEnvironment(cmd)
		if err != nil {
			log.Println("Unable to load environment.")
			log.Fatal(err)
		}
		// get the gcloud id token
		token, err := libops.GetToken(cmd, "token")
		if err != nil {
			log.Fatal(err)
		}

		configSsh, err := cmd.Flags().GetString("config-file")
		if err != nil {
			log.Fatal(err)
		}
		if configSsh == "" {
			// Get the current user
			currentUser, err := user.Current()
			if err != nil {
				fmt.Println(err)
				return
			}

			// Get the home directory
			homeDir := currentUser.HomeDir
			configSsh = filepath.Join(homeDir, ".ssh", "config")
		}
		if _, err := os.Stat(configSsh); os.IsNotExist(err) {
			log.Fatal("Could not find SSH config. Pass the full path as --config-file")
		}

		fileBytes, err := os.ReadFile(configSsh)
		if err != nil {
			log.Println("Unable to read SSH config")
			log.Fatal(err)
		}

		re := regexp.MustCompile(`(?s)# LibOps Section(.*?)# End LibOps Section`)
		// Find the first match of the regular expression in the file contents
		match := re.FindSubmatchIndex(fileBytes)

		// If the block of text exists, replace it with a new block of text
		remove, err := cmd.Flags().GetBool("remove")
		if err != nil {
			log.Fatal(err)
		}
		vm := compute.Instance{}
		var ip string

		// if we're not removing the config, fetch the instance metadata
		if !remove {
			url, err := gcloud.GetCloudRunUrl(site, env)
			if err != nil {
				log.Fatal("Unable to retrieve remote URL")
			}
			req, err := http.NewRequest("GET", fmt.Sprintf("%s/dev", url), nil)
			if err != nil {
				log.Fatal(err)
			}
			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
			resp, err := http.DefaultClient.Do(req)
			if err != nil {
				log.Fatal(err)
			}
			defer resp.Body.Close()

			if resp.StatusCode > 299 {
				log.Fatalf("Unable to get environment info: %v", resp.StatusCode)
			}

			json.NewDecoder(resp.Body).Decode(&vm)
			ip = vm.NetworkInterfaces[0].AccessConfigs[0].NatIP
		}
		host := fmt.Sprintf("%s.%s.site", env, site)
		config := []string{
			`# LibOps Section
#
# The following has been auto-generated by "libops config-ssh"
# to make accessing your LibOps environment easier.
#
# To remove this blob, run:
#
#   libops config-ssh --remove
#
# You can also manually remove this blob by deleting everything from
# here until the comment that contains the string "End LibOps Section".
#
# You should not hand-edit this section, unless you are deleting it.`,
			fmt.Sprintf("Host %s", host),
			fmt.Sprintf("\tHostname %s", ip),
			"\tUser coder",
			"\tPort 2222",
			"\tCheckHostIP=no",
			fmt.Sprintf("\tHostKeyAlias=compute.%d", vm.Id),
		}
		closer := []byte("\n\n# End LibOps Section\n")
		newBlock := []byte(strings.Join(config, "\n"))
		if match == nil {
			c := append(fileBytes, newBlock...)
			c = append(c, closer...)
			// If the block of text doesn't exist, append it to the end of the file
			err = os.WriteFile(configSsh, c, 0644)
			if err != nil {
				log.Printf("Failed to update %s", configSsh)
				fmt.Println(err)
			}
		} else {
			// if the remove flag was passed, remove the block
			if remove {
				newBlock = nil
			}

			existingBlocks, err := helpers.FindHostBlocks(fileBytes, host)
			if err != nil {
				log.Printf("Failed to update %s", configSsh)
				log.Fatal(err)
			}
			newFileBytes := append(fileBytes[:match[0]], append(newBlock, fileBytes[match[1]:]...)...)
			if !remove {
				for _, h := range existingBlocks {
					h = fmt.Sprintf("\n%s\n", h)
					newFileBytes = append(newFileBytes, []byte(h)...)
				}
				newFileBytes = append(newFileBytes, closer...)
			}
			err = os.WriteFile(configSsh, newFileBytes, 0644)
			if err != nil {
				log.Printf("Failed to update %s", configSsh)
				log.Fatal(err)
			}
		}

		log.Printf("Updated %s\n", configSsh)
		if !remove {
			log.Printf("ssh %s\n", host)
		}
	},
}

func init() {
	rootCmd.AddCommand(configSshCmd)

	configSshCmd.Flags().StringP("token", "t", "", "(optional/machines-only) The gcloud identity token to access your LibOps environment")
	configSshCmd.Flags().StringP("config-file", "c", "", "Full path to your SSH config file")
	configSshCmd.Flags().BoolP("remove", "r", false, "Remove the LibOps SSH config block from your config")
}
